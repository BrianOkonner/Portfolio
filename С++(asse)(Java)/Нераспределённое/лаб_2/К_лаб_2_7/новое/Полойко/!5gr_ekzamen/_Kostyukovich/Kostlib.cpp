#include <math.h>
#include "Kostlib.h"

bool prost(double x)
{
	if (x == 1) return false;//Если исходное число 1, то оно не простое
	else
	{
		int i = 2;//Ишем делители, начиная с 2
		while (i <= int (sqrt(x))) //Пока счетчик меньше квадратного корня из исходного числа
		{
			if (((int(x))%i) == 0) return false;//Если на что-то разделили и получили ноль в остатке,то число не простое
			i = i + 1;
		}
		return true;//Если из функции до сих пор не выкинуло, то число простое. Возращаем правду.
	}
}
/////////////////////////
//Функция. Обменная сортировка
void obm(int* mas,int n)
{
	bool flag;
	int co,i,per;
	co=1;
	flag=true;
////////////////
	while (flag)
	{
		flag=false;//Меняем флаг на случай, если массив отсортирован.
		//(Если это так,цикл сортировки в этом убедится и не поменяет флаг => выход из главного цикла)
		i=0;
		while (i!=n-co)//Пока не дойдем до конца неотсортированной части массива
		{
			if (*(mas+i)>*(mas+i+1))//Если предыдущий элемент больше следующего
			{
				per=*(mas+i);//Меняем их местами
				*(mas+i)=*(mas+i+1);
				*(mas+i+1)=per;
				flag=true;//Меняем флаг <=> массив не был отсортирован до прохода по нему,нужно продолжать сортировку
			}
			i=i+1;//Нарастили счетчик
		}
		co=co+1;//Переменная,"отсекающая" от массива отсортированную часть.
	}
}
/////////////////////////
//Функция.Ищет максимальный элемент в массиве.
int maximum(int* mas,int n)
{
	int i;
	int ind;
	i=1;
	ind=0;
////////////////
	while (i!=n)//Пока не дойдем до конца массива
		{
			if (*(mas+i)>*(mas+ind)) ind=i;//Если текущий элемент больше максимального, запоминаем его индекс
			i=i+1;
		}
	return ind;//Возвращаем индекс максимального элемента
}
/////////////////////////
//Функция.Сортировка выбором.
void vyb(int* mas,int n)
{
	int i,per;
////////////////
	while (n>0)//Пока не прошли по всему массиву
	{
		i = maximum(mas,n);//Находим индекс максимального элемента в неотсортированной части массива
		//Меняем местами текущий максимальный элемент на его место
		per=*(mas+i);
		*(mas+i)=*(mas+n-1);
		*(mas+n-1)=per;
		n=n-1;//"Отсекаем" от исходного массива отсротированную часть
	}
}
/////////////////////////
//Функия.Сортировка вставками
void vstav(int *mas, int n)
{
	int i,j,per;
	i=1;
////////////////
	while (i<n)//Пока не дойдем до конца массива
	{
    per=*(mas+i);//Присваиваем per значение i-того элемента
	j=i-1;//Присваиваем счетчику j значение i-1
	while ((j>=0)&&(per<*(mas+j)))//Пока не найдем место для вставки
	{
      *(mas+j+1)=*(mas+j);//Сдвигаем массив
	  j=j-1;
	}
    *(mas+j+1)=per;//Вставляем в найденное место per элемент
	i=i+1;
	}
}
/////////////////////////
int minel(int a, int b, int c)//Поиск минимума из трех чисел
{
	int min=a;
	if (b<min) min=b;
	if (c<min) min=c; 
	return min;
}
/////////////////////////
/*bool sitest(char ch)//Проверка символа на разделитель
{
	const char sign[24]={' ','.',',',';',':','\\','/','!','?','(',')','{','}','[',']','@','\"','+','-','=','*','<','>'};
	int i=0;
	while (i<24)
	{
		if (ch==sign[i]) {return true;}
		else i=i+1;
	}
	if (i==24) return false;
}*/
/////////////////////////
