/*
Каунов Кирилл
1 курс
8 группа

Условие:6.	Задан текстовый файл Input.txt, состоящий  из слов.
Разделителями между словами является некоторое множество знаков препинания.
Найти в каждой строке  слова равные по длине слову каждой строки с наибольшей длиной, удалить и дописать в начало  строки.
Результат записать  в новый файл Output.txt.
Упорядочить слова  в полученных  строках по  убыванию длин слов, результат сортировки записать в файл Out_sort.txt.


Алгоритм:
Разбиваем строку на слова. Пробегаем по строке и находим слово с наибольшей длиной. Пробегаем по этой же строке второй раз,
если длина слова равна длине наибольшего, то сохраняем его в отдельную строку и каждое последующее слово добавляем к нему.
Удаляем слово из текста.
Результат получим соединив полученную строку и исходный текст(с удалёными словами)

Тест:

Ввод:
Казалось бы это вполне нормальная  реакция на такую ситуацию.
 Но простому пользователю не будет понятно, в чём дело и почему на экране не появилась строка из файла.
 так вот, чтобы всё было предельно понятно В С++ предусмотрена такая функция — is_open(), которая возвращает целые значения:
 1 — если файл был успешно открыт, 0 — если файл открыт не был.
 Доработаем программу с открытием файла, таким образом, что если файл не открыт выводилось соответствующее сообщение: ERROR

Вывод1:

нормальная  Казалось бы это вполне   реакция на такую ситуацию.
пользователю  Но простому  не будет понятно, в чём дело и почему на экране не появилась строка из файла.
предусмотрена  так вот, чтобы всё было предельно понятно В С++  такая функция — is_open(), которая возвращает целые значения:
успешно  1 — если файл был  открыт, 0 — если файл открыт не был.
соответствующее  Доработаем программу с открытием файла, таким образом, что если файл не открыт выводилось  сообщение: ERROR

Вывод2:

нормальная Казалось ситуацию реакция вполне такую это бы на
пользователю появилась простому понятно почему экране строка будет файла дело чём Но не на не из
предусмотрена возвращает предельно is_open() значения понятно функция которая чтобы такая целые было так вот всё С++
успешно открыт открыт если файл если файл был был не
соответствующее Доработаем выводилось программу открытием сообщение образом открыт файла таким ERROR если файл что не



*/

#include "MyFunc.h"
#include <iostream>
#include <fstream>
#include <iomanip>
#include <string>

using namespace std;

void delete_s(char *s,char *s1)
{
int j; char *s2=strstr(s,s1);
for ( j=s2-s; j<strlen1(s)-strlen1(s1); j++)
s[j]=s[j+strlen1(s1)];
s[j]=NULL;
}

int main()
{
    setlocale(LC_ALL,".1251");
    char s[100][200], text[100][200], text1[100][200], r[]=",.!?:;- ", *tok;
    char line[200];
    int n, *max;
    ifstream in;    in.open("input.txt");
    ofstream out;   out.open ("output.txt");
    ofstream out_s; out_s.open ("out_sort.txt");

    for (int i=0; i<100; i++)
    {
        n=i;
        in.getline(s[i],200);
        strcpy1(text[i],s[i]);
        strcpy1(text1[i],s[i]);
        if(!s[i][0]) break;
    }
    max = new int [n];
    for (int i=0; i<n; i++)
        max[i] = 0;
    line[0] = '\0';

    for (int i=0; i<n; i++)
    {
        tok = strtok(text[i],r);
        while (tok)
        {
            if (strlen1(tok) > max[i])
                max[i] = strlen1(tok);
            tok = strtok(0,r);
        }
        tok = strtok(text1[i],r);
        while (tok)
        {
            if (strlen1(tok) == max[i])
            {
                strcat1(line, tok);
                strcat1(line, " ");
                delete_s(s[i],tok);
            }
            tok = strtok(0,r);
        }
        strcpy1(text[i],line);
        line[0] = '\0';
    }

    for (int i=0; i<n; i++)
    {
        strcat1 (text[i],s[i]);
        strcpy1 (s[i],text[i]);
        out << text[i] << endl;
    }

    for (int i=0; i<n; i++)             //Сортировка по убыванию
        {
         for (int j=max[i]; j>1; j--)
         {
             tok=strtok(text[i],r);
             while (tok)
                 {
                 if (strlen1(tok)==j) out_s<<tok<<" ";
                 tok=strtok(0,r);
                 }
            strcpy1(text[i],s[i]);
         }
        out_s<<endl;
        }
}