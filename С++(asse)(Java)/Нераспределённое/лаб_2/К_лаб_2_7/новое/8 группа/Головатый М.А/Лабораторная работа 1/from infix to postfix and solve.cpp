/*
Алгоритм задачи преобразования из инфиксной записи в постфиксную форму записи и вычисления:
	Преобразование из инфиксной в постфиксную:
		1. Идём по выражению пока не встретим нулевой символ
		2. Если текущий символ  - число, записываем его в выходную строку
		3. Операции заносим в стек, если + или -, выталкиваем из стека операции с большим приорететом (/*^)
		4. При закрывающейся скобочке также выбрасываем все операторы в выходную строку
		5. В конце выражения также выбрасываем все операции
	Вычисление:
		Для того, чтобы совершать операции над многозначными словами, strtok'ом разбиваем инфиксную строку на числа
		Ищем их в постфиксной строке и вычислем:
		1. Находим число, заносим его в стек, если после него число продолжаем
		2. Если после него знак операции, совершаем операцию над двумя верхними числами стека
		3. И так далее
		4. Число, которое последнее останется в стеке, и будет ответом
Тесты:
Введите ваше инфиксное выражение:(13+2)*4/74-(23-23)+13^2
Выражение в постфиксной форме: 132+4*74/2323--132^+
Результат вычисления: 169.811
*/
#include "header.h"



stack <int> s;
stack <char> s1;

void PostfixNotation(const char *infix, char *postfix)
{
	int st_ptr = 0;			// указатель вершины стека

	int out_index = 0;		// индекс в выходной строке
	int in_index = 0;		// индекс во входной строке
							// начинаем разбор входящей строки (она не должна быть пустой)
	do
	{
		char c = infix[in_index];				// берем текущий символ входной строки

		switch (c)
		{
		case '+':
		case '-':
												// выталкиваем из стека в выходную строку все операторы с большим или равным приоритетом
			while (st_ptr != 0)
			{	char op = s1.top();				// оператор в вершине стека
				if (op != '(')					// все операторы, кроме откр. скобки имеют больший или равный приоритет
				{
					postfix[out_index++] = op;	// добавляем оператор в выходную строку
					s1.pop(); st_ptr--; 		// удаляем оператор из стека
				}
				else
					break;
			}
												// помещаем оператор в стек
			s1.push(c); st_ptr++;
			break;

		case '*':
		case '/':
												// выталкиваем из стека в выходную строку все операторы с большим или равным приоритетом
			while (st_ptr != 0)
			{
				char op = s1.top();
				if ((op == '^') || (op == '*') || (op == '/'))
				{
					postfix[out_index++] = op;	// добавляем оператор в выходную строку
					s1.pop(); st_ptr--;  		// удаляем оператор из стека
				}
				else
					break;
			}
												// помещаем оператор в стек
			s1.push(c); st_ptr++;
			break;

		case '(':
												// просто помещаем в стек
			s1.push(c); st_ptr++;
			break;

		case ')':
		// выталкиваем из стека в выходную строку все элементы до открывающей скобки (откр. скобку просто отбрасываем)
			while (st_ptr != 0)
			{
				char op = s1.top(); st_ptr--; s1.pop();	// забираем из стека оператор
				if (op == '(')							// если достигли открывающей скобки
					break;								// выталкивание закончили
				else
				{
					postfix[out_index++] = op;	// добавили оператор в выходную строку
				}
			}
			break;

		case '^':
			// помещаем оператор в стек (выталкивать ничего не нужно, нет операторов с большим приоритетом)
			s1.push(c); st_ptr++;
			break;

		default:					// символ цифры
			postfix[out_index] = c;	// добавляем цифру в выходную строку
			out_index++;
			break;
		}

		in_index++;					// переходим к следующему символу входной строки
	} while (infix[in_index] != 0);	// разбор закончен

										// выталкиваем все операторы в выходную строку
	while (st_ptr != 0)
	{
		postfix[out_index++] = s1.top(); st_ptr--; s1.pop();
	}
	// завершающий символ нуля
	postfix[out_index] = 0;
}
double calculation(const char* postfix, const char *str_infix)
{
	char *context, delimiter[] = "*+-^/()";
	char **mas = new char*[100];
	char *tmp = new char[strlen(str_infix)];
	strcpy_s(tmp, strlen(str_infix) + 1, str_infix);
	int f = 0;
	for (char *p = strtok_s(tmp, delimiter, &context); p != NULL; p = strtok_s(NULL, delimiter, &context), f++)
	{
		mas[f] = p;
	}
	int k = f;
	f += f - 1;

	double temp = 0;
	int in_index = 0, q = 0;

	double op_a, op_b;
	//находим число в постфиксной записи, заносим его в стек, если далее знак, вычисляем, если нет, ищем слeдующее число и заносим в стек
	int r = 0;
	do
	{
		bool m = false;

		char c = postfix[q];
		if (c == '+' || c == '-' || c == '*' || c == '/' || c == '^')
		{
			op_b = s.top();
			s.pop();
			op_a = s.top();
			s.pop();
			switch (postfix[q])
			{
			case '+':
				temp = op_a + op_b;
				break;
			case '-':
				temp = op_a - op_b;
				break;
			case '*':
				temp = op_a * op_b;
				break;
			case '/':
				temp = op_a / op_b;
				break;
			case '^':
				temp = pow(op_a, op_b);
				break;
			default:
				cout << "Unknown operation " << c << endl;
				//exit(EXIT_FAILURE);
			}
			q++; m = true;
		}
		else
		{
			if (in_index < k)
			{
				q = string(postfix).find(string(mas[in_index]), q);
				temp = atof(mas[in_index]);
			}
			q += strlen(mas[in_index]);
			in_index++;
		}
		s.push(temp);

		f--; r++;
	} while (f != 0);

	return s.top();
}
void condition1()
{
	system("cls");
	cout << setw(5) << " ***********Вычисление выражения в инфиксной форме записи*********** \n";
	cout << "1.1	Задано выражение (инфиксная форма, например (5+45)*(55-5))  содержащее числа (любого типа), знаки операций, \nкруглые скобки. Записать его в виде обратной польской записи (постфиксная форма) и вычислить его значение. ";
}