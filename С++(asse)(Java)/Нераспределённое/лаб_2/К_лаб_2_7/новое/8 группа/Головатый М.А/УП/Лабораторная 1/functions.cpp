
#include "Header.h"
int count(string str)//ФУНКЦИЯ,КОТОРАЯ СЧИТАЕТ КОЛИЧЕСТВО СТРОЧНЫХ БУКВ В СЛОВЕ
{
	int c = 0;
	int l = str.length();
	for (int i = 0; i < l; i++)
		if (str[i] >= 'a' && str[i] <= 'z')
			c++;
	return c;
}
//void COPYSTR(char *a, char *b)
//{
//	int len = LenAsm(b);
//	_asm
//	{
//		mov ecx, len
//		mov edi, a
//		mov esi, b
//		push ecx
//		shr ecx, 2
//		rep movsw
//		pop ecx
//		and ecx, 3
//		rep movsb
//	}
//}
void COPYSTR(char *a, char *b)
{
	int len = LenAsm(b);
	_asm
	{
		mov ecx, len
		inc ecx
		mov esi, b
		mov edi, a
		rep movsb // перемещает из esi в edi и увеличивает esi И edi на 1(т.к. movsB)
	}
}
DWORD LenAsm(char * s)
{
	int  l = 0;
	_asm
	{
		cld;//задаем направление сканирования (сбрасываем флаг DF-флаг направления).
			//данный флаг учитывается в строковых операциях.Если флаг равен 1, то в строковых операциях 
			//адрес автоматически уменьшается.Мы сбрасываем этот флаг,чтобы адрес автоматически увеличивался
		mov edi, s;// помещаем адрес начала строки в регистр EDI
		mov esi, edi;//сохраняем адрес строки в регистре ESI
		mov ecx, 0ffffffffh;//помещаем в регистр-счетчик цикла максимальное 32-битное целое число
		xor al, al;//запускаем бесконечный цикл-операция XOR от двух одинаковых элементов возвращает 0
				   //таким образом,эта команда представляет с собой "пока 0 ..." 
		repne scasb;//сканируем строку байтов, пока не встретится 0
		sub edi, esi;//вычитаем из текущего адреса, который хранится в EDI, адрес начала строки(хранится в ESI ),
					 //таким образом находим длину строки вместе с терминальным символом
		dec edi;//вычитаем из полученной длины строки 1- исключаем терминальный символ
		mov l, edi;//помещаем в переменную l на длину строки
	}
	return l;//возвращаем длину строки
}