//Класс стек-итератор
#include <iostream>
using namespace std;

class IntStack//наш стек
{
	enum {ssize=100};
	int stack[ssize];//массив целых со ста элементами не инициализированнными
	int top;//Переменная с индексом начала стека (если в стеке 50 элементов он равен 50)(далее индекс)
public:
IntStack():top(0){};//Контрутор инициализирует индекс в 0 (стек пуст) верхушка показывает сколько элементов в стеке
	void push(int i)//функция втолкнуть
	{
		if (top>=ssize) exit(1); //если индекс заходит посли операции за пределы определения массива он у нас макс 100 то завершаем прогу
    	stack[top++]=i;//записывает в стек элемент и увеличивает индекс на единицу (индекс показывает сколько элементов но он указывает на "пустой" элемент
	}
	int pop()//достать элемент
	{
		if (top==0) exit(1);//индекс равен нулю доставать неоткуда завершение проги
		return stack[--top];//не равен нулю уменьшаем индекс потом достаем то на что указывает уменьшенный индекс
	}
	class iterator;//вложенный класс "итератор" (я могу ошибаться)
	friend class iterator;//и дружественный класс "итератор" (обЪявляем и так и так как я понял)
	class iterator//его описание (он сам)
	{
		IntStack &s;//он содержит ссылку на объект класса нашего стека и индекс "итератора"(индекс ит)
		int index;//итераторы эт как бы штуки которые содержат ссылки нашего стека и номера с помощью которых мы можем ходить по стеку, сами они не меняют стек
	public:
		iterator(IntStack &is):s(is),index(0){}//конструктор индекс ит установить в ноль и s присвоить данный параметр (делает вместо просто объекта стека объект "итератора")
		iterator(IntStack&is,bool):s(is),index(s.top){}//конструктор индекс ит установить в значение индекса(верхушки) и s присвоить данный параметр (делает вместо просто объекта стека объект "итератора")
		//для различия имеет 2 операнда если второй операнд указывается и он тру то рабодает данный конструктор иначе предыдущий также тут индекс ит указывает на "пустой" элнемент это надо учитывать
		int operator ++()//перегрузка  ++
		{
			if (index>=s.top) exit(3);//если индекс ит заходит за пределы верхушки после операции завершение программы(эт не точно т.к энд 3)
			return s.stack[++index];//однако сдесь может произойти вывод элемента не из стека т.е элемент не проинициализированный т.к ессли индекс ит=индекс -1(index=top-1)то не проверял)
			//в итоге мы получим тот самый мусор
		}
		int operator++(int)
		{
			if (index>=s.top) exit(3);
			return s.stack[index++];
		}
		int operator --()
		{
			if (index<=0) exit(3);
			return s.stack[--index];
		}
		int operator--(int)
		{
			if (index<=0) exit(3);
			return s.stack[index--];
		}
		bool operator == (const iterator& it2)
		{ return (this->index == it2.index);}
		
		bool operator != (const iterator& it2)
		{ return (this->index != it2.index);}
		
		int current()const//текущий элемент на который указывает итератор с помощью индекса ит ,конст как я понял нужен чтобы не менять сам элемент через итератор мы не можем это сделать по его определению
              		  {                 return s.stack[index];    }
		
		friend ostream& operator << (ostream& os, const iterator& it)//перегрузка оператора вывода используя вывводим элемент на который указывает индекс итератора
		{
			os<<it.current()<<" ";//выводит элемент стека на который указывает итератор через пробел почему то пробелов нет
			return os;//возвращает поток вывода (для вывода на экран)
		}
                               };
		iterator begin()
{return iterator(*this);}//загрузить в индекс итератора индекс начала стека
		iterator end()
{return iterator(*this,true);}//загрузить в индекс итератора индекс конца стека используя 2-ой конструктор

};
int main()
{
	IntStack is;//создаем элемент нашего списка
	for(int i=0;i<10;i++) is.push(i);//по циклу заполням список числами от 1 до 9
	IntStack::iterator start = is.begin(),//обьявляем итераторы старт и конец они имеют индексы начала и конца стека (конец это топ(индекс))
	end = is.end();
	while(start!=end)//пока начало неравно нулю по перегрузке понимаем пока индексы ит итераторов неравны
		cout<<--end;//уменьшаем по префиксной форме первая пергрузка -- уменьшаем значения индекса и выводим сверху вниз вывод с 9-ки до 0 индекс сначала уменьшается потому
	//что индекс(верхушки) указывает на пустой элемент он не указывает на элемент в принципе еще раз напишу он говорит о кол-ве эл-тов стека
	system("pause");
	return 0;//конец программы
}
