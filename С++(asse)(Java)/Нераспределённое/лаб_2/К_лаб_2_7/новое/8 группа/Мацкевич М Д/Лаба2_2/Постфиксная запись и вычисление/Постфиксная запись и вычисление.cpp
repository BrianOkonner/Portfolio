/* Мацкевич Максим ПМ 8

Условие:
Задано выражение (инфиксная форма, например (5+45)*(55-5)) 
содержащее числа (любого типа),знаки операций, круглые скобки. 
Записать его в виде обратной польской записи (постфиксная форма)
и вычислить его значение. ";


 Алгоритм:
	1)Преобразование из инфиксной в постфиксную:
	1.	Выpажение сканиpyется слева напpаво, пpи этом pазбивая его  на  числа и знаки аpифметических опеpаций.
2.	Числа записываются в строку том же порядке, в каком встречаются в     исходном  выражении.
3.	Найденный текущий символ арифметической 	операции сравнивается с операцией из стека.
4.	Все операции с пpиоpитетом выше или pавным текyщемy выталкиваем из стека и пишем в выходнyю стpокy 
( выполнение опеpаций с одинаковым пpиоpитетом  бyдет пpоизводиться слева напpаво).
5.	Если пpиоpитет текyщей операции ниже находяйщейся в стеке или стек пустой,
символ операции заносится в стек.
6.	Открывающая скобка заносится в стек. 
Считается, что ее приоритет ниже приоритета всех арифметических операций. 
При нахождении закрывающей  скобки все содержимое стека до первой открывающей скобки удаляется и записывается в строку. 
Открывающая скобка удаляется из стека и в строку не записывается. 
7.	 Когда достигнyт конец входного выpажения,  выталкиваем из стека все что в нем есть в строку.

	2)Вычисление:

8.	Вычисление производится в обратном порядке
9.	 В стек заносим числа,  пока не встретим знак операции. Выполняем операцию над двумя числами  из стека и результат заносим в стек
10.	Процесс завершается когда стек пустой

Тесты:
Ввод:3*(55+45)-200/2
Вывод:Результат вычисления: 200
*/
#include <stack>
#include <iostream>
#include <cmath>
#include "Stack.h"
using namespace std;
double calculation(const char* postfix, const char *str_infix);
Stack  s,s1;
int main ()
{ char infix[100],postfix[100];
cin>>infix;
	int st_ptr = 0;			// указатель вершины стека

	int out_index = 0;		// индекс в выходной строке
	int in_index = 0;		// индекс во входной строке
							// начинаем разбор входящей строки (она не должна быть пустой)
	do
	{
		char c = infix[in_index];				// берем текущий символ входной строки

		switch (c)
		{
		case '+':
		case '-':
												// выталкиваем из стека в выходную строку все операторы с большим или равным приоритетом
			while (st_ptr != 0)
			{	char op = s1.Top();				// оператор в вершине стека
				if (op != '(')					// все операторы, кроме откр. скобки имеют больший или равный приоритет
				{
					postfix[out_index++] = op;	// добавляем оператор в выходную строку
					s1.Pop(); st_ptr--; 		// удаляем оператор из стека
				}
				else
					break;
			}
												// помещаем оператор в стек
			s1.Push(c); st_ptr++;
			break;

		case '*':
		case '/':
												// выталкиваем из стека в выходную строку все операторы с большим или равным приоритетом
			while (st_ptr != 0)
			{
				char op = s1.Top();
				if ((op == '^') || (op == '*') || (op == '/'))
				{
					postfix[out_index++] = op;	// добавляем оператор в выходную строку
					s1.Pop(); st_ptr--;  		// удаляем оператор из стека
				}
				else
					break;
			}
												// помещаем оператор в стек
			s1.Push(c); st_ptr++;
			break;

		case '(':
												// просто помещаем в стек
			s1.Push(c); st_ptr++;
			break;

		case ')':
		// выталкиваем из стека в выходную строку все элементы до открывающей скобки (откр. скобку просто отбрасываем)
			while (st_ptr != 0)
			{
				char op = s1.Top(); st_ptr--; s1.Pop();	// забираем из стека оператор
				if (op == '(')							// если достигли открывающей скобки
					break;								// выталкивание закончили
				else
				{
					postfix[out_index++] = op;	// добавили оператор в выходную строку
				}
			}
			break;

		case '^':
			// помещаем оператор в стек (выталкивать ничего не нужно, нет операторов с большим приоритетом)
			s1.Push(c); st_ptr++;
			break;

		default:					// символ цифры
			postfix[out_index] = c;	// добавляем цифру в выходную строку
			out_index++;
			break;
		}

		in_index++;					// переходим к следующему символу входной строки
	} while (infix[in_index] != 0);	// разбор закончен

										// выталкиваем все операторы в выходную строку
	while (st_ptr != 0)
	{
		postfix[out_index++] = s1.Top(); st_ptr--; s1.Pop();
	}
	// завершающий символ нуля
	postfix[out_index] = 0;
	cout<<postfix;
	cout <<"\n"<<calculation(postfix,infix);
	system("pause");
	return 0;
}


double calculation(const char* postfix, const char *str_infix)
{
	char *context, delimiter[] = "*+-^/()";
	char **mas = new char*[100];
	char *tmp = new char[strlen(str_infix)];
	strcpy_s(tmp, strlen(str_infix) + 1, str_infix);
	int f = 0;
	for (char *p = strtok_s(tmp, delimiter, &context); p != NULL; p = strtok_s(NULL, delimiter, &context), f++)
	{
		mas[f] = p;
	}
	int k = f;
	f += f - 1;

	double temp = 0;
	int in_index = 0, q = 0;

	double op_a, op_b;
	//находим число в постфиксной записи, заносим его в стек, если далее знак, вычисляем, если нет, ищем слeдующее число и заносим в стек
	int r = 0;
	do
	{
		bool m = false;

		char c = postfix[q];
		if (c == '+' || c == '-' || c == '*' || c == '/' || c == '^')
		{
			op_b = s.Top();
			s.Pop();
			op_a = s.Top();
			s.Pop();
			switch (postfix[q])
			{
			case '+':
				temp = op_a + op_b;
				break;
			case '-':
				temp = op_a - op_b;
				break;
			case '*':
				temp = op_a * op_b;
				break;
			case '/':
				temp = op_a / op_b;
				break;
			case '^':
				temp = pow(op_a, op_b);
				break;
			default:
				cout << "Unknown operation " << c << endl;
				//exit(EXIT_FAILURE);
			}
			q++; m = true;
		}
		else
		{
			if (in_index < k)
			{
				q = string(postfix).find(string(mas[in_index]), q);
				temp = atof(mas[in_index]);
			}
			q += strlen(mas[in_index]);
			in_index++;
		}
		s.Push(temp);

		f--; r++;
	} while (f != 0);

	return s.Top();
}

