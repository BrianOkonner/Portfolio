#include <stdlib.h>

extern char* divisors=" ;:,.-()\"!?";	//строка разделителей
extern int	divLength=12;	//на 1 больше, чем надо, т.к. используется в цепочечных командах

void delEndl(char* &str1)	//убирает перенос строки в конце str1
{
	char* str=str1;
	_asm
	{
		mov		esi,str		//кладем в ESI адрес первого элемента строки
wh_:	cmp		[esi],'\0'	//если дошли до конца
		je		end_		//то выходим из цикла
		inc		esi			//иначе переходим на следующий элемент
		jmp		wh_			//и прыгаем в начало
end_:	dec		esi			//смотрим последний элемент строки
		cmp		[esi],'\n'	//если это не перенос
		jne		exit_		//то выходим
		mov		[esi],'\0'	//иначе удаляем его
exit_:
	};
	str1=str;
}
bool ifSent(char* sentence,char* str)	//1, если sentence есть в str
{		
	bool res;
	_asm
	{
		mov		res,1		//по умолчанию отдаем результат TRUE
		xor		ebx,ebx		//очищаем EBX - в нем храним длину предложения
		mov		edx,sentence//кладем в EDX адрес начала предложения
		dec		edx			//уменьшаем EDX, чтобы начать сначала
wh0_:	inc		edx			//увеличиваем EDX
		inc		ebx			//увеличиваем счетчик
		cmp		[edx],'\0'	//если строка не закончилась
		jne		wh0_		//то возвращаемся в начало цикла
				//сейчас в EBX число, на 1 большее длины слова, но так надо для последующей работы с цепочечными командами

		mov		eax,sentence//кладем в EAX адрес начала предложения
		mov		edx,str		//кладем в EDX адрес начала строки
wh1_:	cmp		[edx],'\0'	//если строка закончилась
		je		end0_		//то получаем нулевой результат
		mov		edi,edx		//иначе кладем EDX в EDI
		inc		edx		//и увеличиваем EDX
		mov		esi,eax		//EAX в ESI
		mov		ecx,ebx		//счетчик в ECX
		repe	cmpsb		//и сравниваем предложение со строкой
		cmp		ecx,0		//если оно не содержится в ней
		jne		wh1_		//то переходим в начало цикла
		jmp		exit_		//иначе выходим с положительным результатом

end0_:	mov		res,0		//в случае нулевого результата возвращаем 0
exit_:
	};
	return res;
}

char* findFirstWord(char* str,int& len)	//возвращает указатель на 1е слово, в len - длину слова
{
	char* res=NULL;
	int n;
	_asm
	{
		mov		esi,str		//записываем в ESI указатель на 0й элемент str
		mov		ebx,divisors//записываем в EBX указатель на 0й элемент divisors
		mov		edx,0		//положили в EDX 0 - это длина первого слова
		cld					//DF = 0

wh1_:	cmp		[esi],'\0'	//если в [ESI] конец строки
		je		out0_		//выходим с нулевым результатом
		mov		edi,ebx		//записываем в EDI адрес массива разделителей
		mov		al,[esi]	//кладем в AL текущий элемент
		mov		ecx,divLength		//положили в ECX количество разделителей (!)
		repne	scasb		//проверяем, лежит ли в AL разделитель
		cmp		ecx,0		//если нет,
		je		out1_		//то выходим из цикла
		inc		esi			//иначе переходим на следующий элемент
		jmp		wh1_		//и возвращаемся в начало цикла

out1_:	//получили в esi первый неразделитель
		mov		res,esi		//вернули в res указатель на слово
		dec		esi			//уменьшили ESI

		//идем до конца слова
wh2_:	inc		edx			//увеличиваем длину слова
		inc		esi			//переходим на следующий символ строки
		mov		edi,ebx		//кладем в EDI адрес начала массива разделителей
		cmp		[esi],'\0'	//если строка закончилась
		je		out2_		//то выходим
		mov		al,[esi]	//иначе кладем в AL текущий символ
		mov		ecx,divLength		//положили в ECX количество разделителей
		repne	scasb		//проверяем, лежит ли в AL разделитель
		cmp		ecx,0		//если нет
		je		wh2_		//то идем в начало цикла
						//иначе вышли из цикла
out2_:	dec		edx			//уменьшаем EDX т.к. увеличили его лишний раз
		mov		n,edx		//возвращаем длину слова
		jmp		exit_		//выходим

out0_:	mov		res,esi		//в нулевом случае возвращаем указатель на '\0'
		mov		n,edx		//и длину слова = 0
exit_:
	};
	len=n;
	return res;
}

char* findLastWord(char* str,int& len)
{					//принцип работы такой же, как и в findFirstWord, но мы идем по слову задом наперед
	char* res;
	int n;
	_asm
	{
		mov		esi,str		//кладем в ESI адрес начала строки
		mov		ebx,divisors//кладем в EBX адрес начала массива разделителей
		cld					//DF = 0
			//добираемся к хвосту строки
		dec		esi			//уменьшаем ESI, чтобы в цикле начать с первого символа
whend_: inc		esi			//переходим к следующему символу
		cmp		[esi],'\0'	//если это не нулевой байт
		jne		whend_		//то возвращаемся в начало цикла
		mov		res,esi		//иначе возвращаем в res адрес нулевого байта
		dec		esi			//и уменьшаем ESI, получив в нем адрес последнего символа строки

		xor		edx,edx		//очищаем EDX, в нем будем хранить длину слова
wh1_:	cmp		esi,str		//если мы дошли до начала слова
		je		out0_		//то выходим с нулевым результатом
		mov		edi,ebx		//иначе кладем в EDI адрес начала массива разделителей
		mov		al,[esi]	//записываем в AL текущий символ
		mov		ecx,divLength		//кладем в ECX количество разделителей
		repne	scasb		//проверяем, лежит ли в AL разделитель
		cmp		ecx,0		//если нет, то
		je		out1_		//выходим из цикла
		dec		esi			//иначе переходим к предыдущему символу
		jmp		wh1_		//и возвращаемся в начало цикла

		out1_:	//получили в esi первый неразделитель
		inc		esi			//увеличиваем ESI для последующего уменьшения

		//идем до конца слова
wh3_:	inc		edx			//увеличиваем длину слова
		dec		esi			//переходим на предыдущий символ
		mov		edi,ebx		//кладем в EDI адрес начала массива разделителей

		cmp		esi,str		//если мы дошли до начала строки
		je		out2_		//то выходим из цикла
		mov		al,[esi]	//иначе кладем в AL текущий символ
		mov		ecx,divLength		//кладем в ECX количество разделителей
		repne	scasb		//проверяем, лежит ли в AL разделитель
		cmp		ecx,0		//если нет, то
		je		wh3_		//возвращаемся в начало цикла
					//иначе вышли из цикла
out2_:	inc		esi			//увеличиваем ESI, т.к. уменьшили его лишний раз
		dec		edx			//уменьшаем EDX по аналогичной причине
		mov		res,esi		//возвращаем адрес из ESI
out0_:	mov		n,edx		//возвращаем длину слова - EDX

	};
	len=n;
	return res;
}

char* detFirstWord(char* &str)	//отделяет 1е слово от str и возвращает указатель на 1е слово
{
	char *str1=str,*res;
	int n=0;
	_asm
	{
		lea		ebx,n			//кладем в EBX адрес n
		mov		esi,str1		//кладем в ESI адрес 0го элемента строки
		mov		edi,divisors	//в EDI - адрес начала строки разделителей
		push	ebx				//кладем в стек
		push	esi				//параметры для функции findFirstWord
		call	findFirstWord	//вызываем, в EAX адрес первого элемента слова 
		
		pop		ecx				//
		pop		ecx				//возвращаем стек в первоначальное состояние
		mov		res,eax			//возвращаем адрес первого элемента слова
		cmp		res,NULL		//если слов в строке не было
		je		exit_			//то выходим
		add		eax,n			//переходим на следующий элемент после слова
		cmp		[eax],'\0'		//если пришли в конец строки, то ничего не меняем
		je		exit_			//и выходим 
		mov		[eax],'\0'		//иначе отделяем слово нулевым байтом
		inc		eax				//переходим в следующий символ
exit_:	mov		str1,eax		//изменяем адрес начала строки
	};
	str=str1;
	return res;
}

char* addWordEnd(char* &dest,char* source,unsigned int n=0)	//добавляем слово в конец строки, необязательный параметр n - сколько элементов добавляем, если n=0, то добавляем все слово
						//возвращаем адрес строки
{
	char *str=dest;
	_asm
	{
		cld					//устанавливаем DF = 0
		mov		esi,source	//записываем в ESI адрес 0го элемента слова
		xor		ecx,ecx		//очищаем счетчик ECX
wh1_:	cmp		[esi],'\0'	//если текущий символ - нулевой байт
		je		next_		//то выходим из цикла
		inc		ecx			//иначе увеличиваем счетчик
		inc		esi			//переходим на следующий символ	
		jmp		wh1_		//и идем в начало цикла
				//получаем в ECX длину слова
next_:	cmp		n,0			//если n=0
		je		end_		//то продолжаем работу
		cmp		ecx,n		//если ECX не превышает n
		jng		end_		//то продолжаем работу
		mov		ecx,n		//иначе кладем в ECX n
			//добавляем строку
end_:	mov		edi,str		//кладем в EDI адрес 0го символа конечной строки
		mov		esi,source	//в ESI - 0го элемента слова
wh2_:	cmp		[edi],'\0'	//если текущий символ - нулевой байт
		je		end2_		//то выходим из цикла
		inc		edi			//иначе переходим к следующему символу
		jmp		wh2_		//и идем в начало цикла
			//в EDI теперь адрес нулевого байта конечной строки
end2_:	rep		movsb		//добавляем ECX символов слова к строке
		mov		[edi],'\0'	//и завершаем строку нулевым байтом

	};
	return str;
}

void sortArrWord(char** &arr1,int len)	//сортировка массива arr1 длины len методом пузырька (выбран был как удобней всего реализуемый в asm и на массиве слов)
{					//len < 256 !!
	char** arr=arr1;
	_asm
	{
		cld						//устанавливаем DF = 0
		mov		ebx,arr			//кладем в EBX адрес 0го слова
		mov		ch,byte ptr len	//кладем в CH len - первый счетчик
				//главный цикл
wh1_:	cmp		ch,1			//если CH=1
		je		exit_			//то заканчиваем работу главного цикла
		mov		cl,ch			//кладем в CL CH - второй счетчик
		mov		edx,ebx			//кладем в EDX адрес 0й строки
wh2_:	cmp		cl,1			//если CL=1
		je		end_			//то выходим из вспомогательного цикла
		mov		esi,[edx]		//кладем в ESI адрес 0го символа рассматриваемой строки
		mov		edi,[edx+4]		//кладем в EDI адрес 0го символа следующей строки
				//сравниваем, сначала длину
len_:	cmp		[esi],'\0'		//если ESI закончилась,
		je		outs_			//то выходим
		cmp		[edi],'\0'		//если EDI закончилась
		je		outd_			//то выходим
		inc		esi				//переходим на следующий символ ESI
		inc		edi				//переходим на следующий символ ESI
		jmp		len_			//идем в начало цикла
outs_:	cmp		[edi],'\0'		//если EDI не закончился
		jne		ch_				//то меняем ESI и EDI местами
		jmp		endl_			//иначе продолжаем сравнивать
outd_:	cmp		[esi],'\0'		//если ESI не закончился
		jne		endc_			//то не меняем, иначе сравниваем дальше
endl_:	mov		esi,[edx]		//
		mov		edi,[edx+4]		//вернемся к началам слов из ESI и EDI

			//если начать сравнение отсюда, то мы отсортируем слова в алфавитном порядке
whc_:	cmp		[edi],'\0'		//если EDI закончилась
		je		endc_			//то менять не надо, EDI не больше
		cmpsb					//иначе сравниваем соответствующие символы слов
		jg		endc_			//если ESI больше, то выходим без обмена
		je		whc_			//если символы равны, продолжаем цикл
				//меняем местами указатели
ch_:	push	dword ptr [edx]	
		push	dword ptr [edx+4]
		pop		dword ptr [edx]
		pop		dword ptr [edx+4]
				//закончили обмен
endc_:	add		edx,4			//переходим к следующему слову
		dec		cl				//уменьшаем счетчик CL
		jmp		wh2_			//и идем в начало цикла
				//конец вспомогательного цикла
end_:	dec		ch				//уменьшаем счетчик
		jmp		wh1_			//и идем в начало цикла
				//конец основного цикла
exit_:	//массив отсортирован
	};
	arr1=arr;
}