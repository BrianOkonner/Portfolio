/*1.	Использование (динамического) стека.
1.1	Задано выражение (инфиксная форма, например (5+45)*(55-5))  содержащее числа (любого типа), знаки операций, круглые скобки.
Записать его в виде обратной польской записи (постфиксная форма) и вычислить его значение. 
1.2	Описать процедуру, которая подсчитывает количество элементов стека, у которых равные "соседи".
Преобразовать инфиксную строку-выражение в постфиксную строку-выражение  и вычислить ее результат.

Инфиксная
	((A+B*(D-E))/(F+G)
	Префиксная
/*+AB-DE+FG
	Постфиксная
ABDE-*+FG+/

Алгоритм:
1.	Выpажение сканиpyется слева напpаво, пpи этом pазбивая его  на  числа и знаки аpифметических опеpаций.
2.	Числа записываются в строку том же порядке, в каком встречаются в     исходном  выражении.
3.	Найденный текущий символ арифметической 	операции сравнивается с операцией из стека.
4.	Все операции с пpиоpитетом выше или pавным текyщемy выталкиваем из стека и пишем в выходнyю стpокy ( выполнение опеpаций с одинаковым
пpиоpитетом  бyдет пpоизводиться слева напpаво).
5.	Если пpиоpитет текyщей операции ниже находяйщейся в стеке или стек пустой, символ операции заносится в стек.
6.	Открывающая скобка заносится в стек. Считается, что ее приоритет ниже приоритета всех арифметических операций. 
При нахождении закрывающей  скобки все содержимое стека до первой открывающей скобки удаляется и записывается в строку. 
Открывающая скобка удаляется из стека и в строку не записывается. 
Алгоритм
Пока есть ещё символы для чтения:
Читаем очередной символ.
Если символ является числом, добавляем его к выходной строке..
Если символ является открывающей скобкой, помещаем его в стек.
Если символ является закрывающей скобкой:
До тех пор, пока верхним элементом стека не станет открывающая скобка, выталкиваем элементы из стека в выходную строку. При этом открывающая скобка удаляется из стека, но в выходную строку не добавляется. Если стек закончился раньше, чем мы встретили открывающую скобку, это означает, что в выражении либо неверно поставлен разделитель, либо не согласованы скобки.
Если символ является оператором о1, тогда:
1) пока приоритет o1 меньше либо равен приоритету оператора, находящегося на вершине стека выталкиваем верхние элементы стека в выходную строку;
2) помещаем оператор o1 в стек.
Когда входная строка закончилась, выталкиваем все символы из стека в выходную строку. В стеке должны были остаться только символы операторов; если это не так, значит в выражении не согласованы скобки.
*/ 

#include <iostream>
#include <fstream>
#include <queue>
#include <list>
#include <stack>
#include "fun_h.h"
using namespace std;
//int prrr(stack <char[15]> s,stack <double> l);
void main()
{
	ifstream in;
	ofstream out("out.txt");
	in.open("in.txt");
    int i=0;
    setlocale(LC_ALL,".1251");
	char t[15],g;
	stack <char> s; stack <double> l;
	while(!in.eof())
	{
		i=0;
		in>>t[0];
		i++;
		if(isalnum(t[0])!=NULL)
		{
			while(in>>t[i]&&(isalnum(t[i])!=NULL||t[i]==','))
			{
				i++;
			}
			if(t[i]=='(')
			{
				g = t[i];
				s.push(g);
				out << strtod(t, '\0');
			}
			else
				if (t[i] == ')')
				{
					while (s.top() != '(')
					{
						out << s.top();
						s.pop();
					}
					s.pop();
				}
				else
				{
					if (t[i] == '*'&&t[i] == '/')
					{
						while (s.top() == '*' || s.top() == '/')
						{
							out << s.top();
							s.pop();
						}
						s.push(t[i]);
					}
					else
					{
						while (s.empty()==0||s.top() != '(' || s.top() != ')')
						{
							out << s.top();
							s.pop();
						}
					s.push(t[i]);
					}
					t[i]='\0';
					out << strtod(t, '\0');
					s.push(g);
				}
		}
		else
			if (t[i] == '(')
			{
				g = t[i];
				s.push(g);
				out << strtod(t, '\0');
			}
			else
				if (t[0] == ')')
				{
					while (s.top() != '(')
					{
						out << s.top();
						s.pop();
					}
					s.pop();
				}
				else
					if (t[i] == '*'&&t[i] == '/')
					{
						while (s.top() == '*' || s.top() == '/')
						{
							out << s.top();
							s.pop();
						}
						s.push(t[i]);
					}
					else
					{
						while (s.empty() != 0 || s.top() != '(' || s.top() != ')')
						{
							out << s.top();
							s.pop();
						}
						s.push(t[i]);
					}
		/*else
			if(t[0]==')'||t[0]=='(')
			{
				t[0]='\0';
			}
			else
			{
				g=t[0];
				s.push(g);
			}*/
	}
}
	/*s.push("(");
	s.push("5");
	s.push("+");
	s.push("45");
	s.push(")");
	s.push("*");
	s.push("(");
	s.push("55");
	s.push("-");
	s.push("5");
	s.push(")");
	s.push(")");*/
	/*while(!s.empty())
	{
		if(prrr(s,l)==1)
		{
			s.swap(m);
		}
		else
		{
			s.pop();
		}
	}
}
int prrr(stack <char[15]> s,stack <double> l)
{
	int i,n=0;
	for(i=0;i<10;i++)
		l.push(i);
	for(i=0;i<10;i++)
		if(((atof(s.top())%10)-1)==l.top()&&s.top()!="0")
		{
			n=1;
		}
		else
		{
			l.pop();
		}
		return n;
}
/*	f.push(1);
	f.push(2);
	f.push(3);
	f.push(5);
	f.push(7);
	f.push(11);
	f.push(13);
	f.push(17);
	f.push(29);
	d.push(121);
	d.push(232);
	d.push(323);
	d.push(431);
	d.push(55);
	d.push(171);
	d.push(131);
	d.push(171);
	d.push(292);*/
