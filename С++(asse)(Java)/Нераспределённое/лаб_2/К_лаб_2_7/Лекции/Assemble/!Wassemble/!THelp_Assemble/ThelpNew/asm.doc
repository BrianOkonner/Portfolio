                                 - 1 -


╔══════════════════════════════════════════════════════════════════════════════╗
║                          Арифметические инструкции                           ║
╚══════════════════════════════════════════════════════════════════════════════╝

ADD  dest,src         сложить два операнда, помещая результат в dest            
                       dest(src + dest)                                        
ADC  dest,src         сложить два операнда, учитывая перенос из предыдущего ADD 
                       dest(src + dest + CF)                                   
INC  dest             прибавить 1 кo dest (reg или r/m)                         
                       dest(dest+1)                                            
                                                                                
SUB  dest,src         вычесть src из dest, оставляя результат в dest            
                       dest(dest - src)                                        
SBB  dest,src         вычитание с заемом (carry-флаг) у предыдущего SUB         
                       dest((dest - src) - CF)                                 
DEC  dest             вычесть 1 из dest (reg или r/m)                           
                       dest(dest - 1)                                          
                                                                                
CMP  dest,src         сравнение (неразрушающее вычитание)                       
                       флаги отражают перенос, переполнение и т.п.              
                                                                                
NEG  dest             изменить знак операнда                                    
                       dest(0 - dest);                                         
                                                                                
AAA                   подгонка после ASCII-сложения                             
                       AL(AL исправленный для ASCII-сложения)                  
AAS                   подгонка после ASCII-вычитания                            
                       AL(AL исправленный для ASCII-вычитания)                 
AAM                   подгонка после ASCII-умножения                            
                       AH:AL(AH:AL испр. для ASCII-умножения)                  
AAD                   подгонка перед ASCII-делением                             
                       AH:AL(AH:AL подготовл. для деления кодов ASCII)         
                                                                                
DAA                   подгонка после BCD-сложения                               
                       AL(AL испр. для BCD-сложения)                           
DAS                   подгонка для BCD-вычитания                                
                       AL(AL испр. для BCD-вычитания)                          
                                                                                
MUL src               умножить AL(AX) на значение без знака (reg/mem)           
                       AX(AL * src8)                                           
                       DX:AX(AX * src16)                                       
IMUL src              умножить AL(AX) на целое со знаком (reg/mem)              
                       AX(AL * immed8)                                         
                       DX:AX(AX * immed16)                                     
IMUL reg16,r/m,immed  умнож. reg/mem на 16-бит. непоср. со знаком      ▌286▐    
                       reg16(r/m8 * immed)                                     
                       reg16(r/m16 * immed)                                    
                                                                                
DIV  src              разделить аккумулятор на значение без знака (reg/mem)     
                      Деление нана или переполнение результата вызывают INT 0.  
                       AL(AX Ў src8); AH(AX MOD src8)                         
                       AX(DX:AX Ў src16); DX(DX:AX MOD src16)                 
IDIV src              разделить аккумулятор на значение без знака (reg/mem)     
                                                                                
CBW                   конвертировать байт в слово (расширить знак AL в AH)      
                       AH(заполнен битом 7 из AL)                              
CWD                   конвертировать word в dword (расширить знак AX в DX)      
                       DX(заполнен битом 15 из AX)                             
                                                                                
AND  dest,src         логическое И (маска; сброс битов dest, равных 0 в src)    
                                 - 2 -

                       dest(dest & src)                                        
                       AH(заполнен битом 7 из AL)                              
CWD                   конвертировать word в dword (расширить знак AX в DX)      
                       DX(заполнен битом 15 из AX)                             
                                                                                
AND  dest,src         логическое И (маска; сброс битов dest, равных 0 в src)    
                       dest(dest & src)                                        
TEST dest,src         неразрушающее И (проверка битов; переход JZ по несовп.)   
                       флаги(как для dest & src)                               
                                                                                
OR   dest,src         включающее ИЛИ (установка битов dest, равных 1 в src)     
                       dest(dest | src)                                        
                                                                                
XOR  dest,src         исключающее ИЛИ (инверсия битов dest, равных 1 в src)     
                       dest(dest ^ src)                                        
                                                                                
NOT  dest             дополнение до единиц (инвертирование всех битов в dest)   
                       dest(~dest)                                             
────────────────────────────────────────────────────────────────────────────────
                                                               Набор инструкций  

╔══════════════════════════════════════════════════════════════════════════════╗
║                          Инструкции передачи данных                          ║
╚══════════════════════════════════════════════════════════════════════════════╝

MOV  dest,src        переслать данные в/из регистра, в/из памяти                
                      destsrc                                                  
                                                                                
XCHG dest,src        обменять значения двух регистров или регистра и r/m        
                      dest  src                                                
                                                                                
IN   port8 (или DX)  ввод в AL(или AX) из порта в/в                             
                      байт:  ALпорт                                            
                      слово: AL[порт]; AH[порт+1]                             
OUT  port8 (или DX)  вывод из AL(или AX) в порт в/в                             
                      байт:  [порт]AL                                          
                      слово: [порт]AL [порт+1]AH                              
                                                                                
XLAT                 транслировать AL согласно таблице трансляции в BX          
                      ALES:[BX+(AL)]                                           
                                                                                
LEA  reg16,addr      загрузить адрес в регистр                                  
                       reg16(результат вычисления исполнительного адреса)      
                                                                                
LDS  reg16,mem       загрузить DS и reg16 из поля памяти                        
                      reg16[mem16]; DS[mem16+2]                               
LES  reg16,mem       загрузить ES и reg16 из поля памяти                        
                      reg16[mem16]; ES[mem16+2]                               
                                                                                
LAHF                 загрузить флаги в AH                                       
SAHF                 поместить AH в флаги                                       
                                                                                
PUSH src             переслать reg16 или r/m16 в стек                           
                      SP-=2; SS:[SP]src                                        
PUSH immed           переслать immed16 (или расширение со знаком immed8) в стек.
                     SP-=2; SS:[SP]immed16    ▌286▐ только.                    
                                                                                
PUSHA                PUSH ALL: скопировать общие регистры в стек.  ▌286▐ только.
                      SP-=10H; AX,BX,CX,DX,SI,DI,BP,SP сохраняются в стеке      
                                                                                
                                 - 3 -

PUSHF                PUSH Flags: переслать регистр флагов в стек                
                      SP-=2; SS:[SP]флаги                                      
                                                                                
PUSH immed           переслать immed16 (или расширение со знаком immed8) в стек.
                     SP-=2; SS:[SP]immed16    ▌286▐ только.                    
                                                                                
PUSHA                PUSH ALL: скопировать общие регистры в стек.  ▌286▐ только.
                      SP-=10H; AX,BX,CX,DX,SI,DI,BP,SP сохраняются в стеке      
                                                                                
PUSHF                PUSH Flags: переслать регистр флагов в стек                
                      SP-=2; SS:[SP]флаги                                      
                                                                                
POP  dest            переслать из стека в reg16 или r/m16 или segreg            
                      destSS:[SP]; SP+=2                                       
                                                                                
POPA                 POP All: скопировать общие регистры из стека. ▌286▐ только.
                      SP+=10H; AX,BX,CX,DX,SI,DI,BP восстанавливаются из стека  
                                                                                
POPF                 POP Flags: переслать из стека в регистр флагов             
                      flagsSS:[SP]; SP+=2                                      
────────────────────────────────────────────────────────────────────────────────
                                                               Набор инструкций  

╔══════════════════════════════════════════════════════════════════════════════╗
║                      Инструкции управления выполнением                       ║
╚══════════════════════════════════════════════════════════════════════════════╝

JMP     target       безусловная передача управления на метку                   
                         short: IP(IP+(смещение цели, расширенное со знаком)   
                          near: IP(IP+(смещение цели)                          
                      indirect: IP(регистр или значение в памяти)              
                           far: SSцелевой_сегмент; IPцелевое_смещение         
                                                                                
JCXZ    short_label  переход если CX==0                                         
                                                                                
LOOP    short_label  CX(CX-1) переход если CX!=0                               
LOOPE/  short_label  CX(CX-1) переход если CX!=0 && ZF==ZR==1                  
 LOOPZ                                                                          
LOOPNE/ short_label  CX(CX-1) переход если CX!=0 && ZF==NZ==0                  
 LOOPNZ                                                                         
                                                                                
Jcond   short_label  переход при удовлетворении условия                         
                     IP(IP+(8-битовое смещение, расширенное со знаком до 16))  
                                                                                
JA/JNBE short_label  переход если выше ((CF & ZF)==0 после беззнак ариф)        
JAE/JNB short_label  переход если выше/равно (CF==NC==0 после беззнак ариф)     
JE/JZ   short_label  переход если равно (ZF==ZR==1)                             
JG/JNGE short_label  переход если больше (SF==(OF & ZF) после знак ариф)        
JGE/JNL short_label  переход если больше/равно (SF==OF после знак ариф)         
JL/JNGE short_label  переход если меньше (ZF != OF после знак ариф)             
JLE/JNG short_label  переход если меньше/равно (SF!=OF || ZF==0 после знак ариф)
`mC     short_label  переход если не Carry (CF==NC==0) (то же, что JAE/JNB)     
JNE/JNZ short_label  переход если не равно (ZF==NZ==0)                          
JNO     short_label  переход если не переполнение (OF==NO==0)                   
JNP/JPO short_label  переход если нечет (PF==PO==0: число 1-битов НЕЧЕТНО)      
JNS     short_label  переход если не знак (SF==PL==0: -- старший бит dest)      
JO      short_label  переход если переполнение (OF==OV==1)                      
JP/JPE  short_label  переход еслблчет(PF==PE==1 число 1-битов ЧЕТНО)            
JS      short_label  переход если знак (SF==NG==1: -- старший бит dest)         
                                                                                
                                 - 4 -

BOUND   reg16,lmts   проверить диапазон для reg16. 'lmts' - адрес 2-словной     
                     таблицы с заданными границами min/max.      ▌286▐ только.  
                     если (reg16<DS:[lmts]) или (reg16>DS:[lmts+2]) то INT 5    
                                                                                
ENTER   frmsiz,frms  уст. фрейм стека языка высокого уровня. Первая операция в  
                     вызываемой (CALL) процедуре.   ▌286▐ только. То же, что и: 
                      PUSH BP;      (повторить frms раз)                        
                      MOV BP,SP;                                                
                      PUSH SP;                                                  
                      SUB SP,frmsize ;(распределить динамич. память в стеке)    
                                                                                
LEAVE                отменить действие ENTER. Используется перед RET.           
                     Восстанавливает SP и BP к значениям перед ENTER.           
                                                                                
INT type             выполнить программное прерывание (вызов системной функции) 
                      PUSHF; IF0; TF0;                                        
                      PUSH CS; PUSH IP                                          
                      IP 0000:[type * 4]; CS  0000:[(type * 4) + 2]           
                                                                                
INTO type            если OF==OV==1, то выполнить INT type                      
                                                                                
IRET                 возврат из прерывания. Действие эквивалентно следующему:   
                      POP IP; POP CS; POPF                                      
                      PUSH BP;      (повторить frms раз)                        
                      MOV BP,SP;                                                
                      PUSH SP;                                                  
                      SUB SP,frmsize ;(распределить динамич. память в стеке)    
                                                                                
LEAVE                отменить действие ENTER. Используется перед RET.           
                     Восстанавливает SP и BP к значениям перед ENTER.           
                                                                                
INT type             выполнить программное прерывание (вызов системной функции) 
                      PUSHF; IF0; TF0;                                        
                      PUSH CS; PUSH IP                                          
                      IP 0000:[type * 4]; CS  0000:[(type * 4) + 2]           
                                                                                
INTO type            если OF==OV==1, то выполнить INT type                      
                                                                                
IRET                 возврат из прерывания. Действие эквивалентно следующему:   
                      POP IP; POP CS; POPF                                      
────────────────────────────────────────────────────────────────────────────────
                                                               Набор инструкций  

╔══════════════════════════════════════════════════════════════════════════════╗
║                      Инструкции управления процессором                       ║
╚══════════════════════════════════════════════════════════════════════════════╝
                                                                                
CLC         очистить флаг переноса                                 (CF0)       
CMC         инвертировать значение флага переноса                  (CF ~CF)    
STC         взвести флаг переноса                                  (CF1)       
CLD         очистить флаг направления (автоинкремент строк)        (DF0)       
STD         взвести флаг направления (автодекремент строк)         (DF1)       
CLI         запретить маскируемые аппаратные прерывания            (IF0)       
STI         разрешить маскируемые аппаратные прерывания            (IF1)       
                                                                                
CTS         взвести флаг переключения задач.  ▌286▐ только.        (TF1)       
                                                                                
HLT         остановить работу процессора (ждать прерывания)                     
                                                                                
WAIT/FWAIT  ждать активности TEST-линии (синхронизация с сопроцессором)         
                                 - 5 -

LOCK        (префикс) предотвратить выборку сопроцессором следующей инструкции  
                                                                                
SEG segreg  (префикс) перекрыть умалчиваемый segreg для очередного вычисления EA
────────────────────────────────────────────────────────────────────────────────
                                                               Набор инструкций  

╔══════════════════════════════════════════════════════════════════════════════╗
║                        Инструкции строковой обработки                        ║
╚══════════════════════════════════════════════════════════════════════════════╝

CLD                  очистить флаг направления (DFUP0)                        
                       (Delta) - положительна, автоинкремент строк             
STD                  взвести флаг направления (DFDN1)                         
                       (Delta) - отрицательна, автодекремент строк             
                                                                                
REP/REPE/REPZ        (префикс) повтор: повторять строковую операцию             
                      CX(CX-1); операция повторяется до момента CX==0          
REPNE/REPNZ          (префикс) повтор: полезно для операций CMPS и SCAS         
                      ZF0; CX(CX-1); операция повторяется пока (CX!=0 и ZF==0)
                                                                                
MOVSB                копировать строку байт (слов) (байт:=1, слов:=2)         
MOVSW                 ES:[DI]DS:[SI]; DI+=; SI+=                             
                                                                                
LODSB                копировать строку байт (слов) в AL(AX)                     
                      AL  DS:[SI]; SI+=1;                                      
LODSW                 AX  DS:[SI]; SI+=2;                                      
                                                                                
STOSB                поместить байт (слово) в строку                            
                      ES:[DI]AL; DI+=1;                                        
                      ES:[DI]AL; DI+=1;                                        
STOSW                 ES:[DI]AX; DI+=2;                                        
                                                                                
CMPSB                сравнить строки байт (слов) (байт:=1, слов:=2)           
CMPSW                 флаги(результат CMP DS:[SI],ES:[DI]); DI+=; SI+=       
                                                                                
SCASB                найти байт (слово) в строке                                
                      флаги(результат CMP DS:[DI],AL); DI+=1                   
SCASW                 флаги(результат CMP DS:[DI],AX); DI+=2                   
                                                                                
INSB                 байт (слово) из порта в строку (байт:=1, слово:=2)       
INSW                 ▌286▐ только.                                              
                      ES:[DI](байт/слово из порта DX); DI+=;                  
                                                                                
OUTSB                байт (слово) из строки в порт (байт:=1, слово:=2)        
OUTSW                ▌286▐ только.                                              
                      [порт DX]DS:[SI]; SI+=;                                 
────────────────────────────────────────────────────────────────────────────────
                                                               Набор инструкций  

╔══════════════════════════════════════════════════════════════════════════════╗
║                        Инструкции управления защитой                         ║
╚══════════════════════════════════════════════════════════════════════════════╝

Все инструкции здесь действительны только для ▌286▐ (недоступны на 8088/86)     
                                                                                
LGDT src       загрузить таблицу глобальных дескрипторов (GDT) из src (6 байт)  
SGDT dest      поместить 6-байтовую GDT в память по адресу dest                 
                                                                                
LIDT src       загрузить таблицу дескрипторов прерываний (IDT) из src (6 байт)  
SIDT dest      поместить 6-байтовую IDT в память по адресу dest                 
                                 - 6 -

                                                                                
LLDT src       загрузить таблицу локальных дескрипторов (LDT) из reg/mem16      
SLDT dest      поместить регистр LDT в dest (r/m16)                             
                                                                                
LMSW src       загрузить слово состояния машины (MSW) (для защищенного режима)  
SMSW src       поместить MSW в reg/mem16                                        
                                                                                
LTR  src       загрузить регистр задачи (TR) из reg/mem16                       
STR  dest      поместить TR в reg/mem16                                         
                                                                                
LAR  dest,src  загрузить в старший байт dest права доступа из дескриптора src   
                                                                                
SLDT dest      поместить регистр LDT в dest (r/m16)                             
                                                                                
LMSW src       загрузить слово состояния машины (MSW) (для защищенного режима)  
SMSW src       поместить MSW в reg/mem16                                        
                                                                                
LTR  src       загрузить регистр задачи (TR) из reg/mem16                       
STR  dest      поместить TR в reg/mem16                                         
                                                                                
LAR  dest,src  загрузить в старший байт dest права доступа из дескриптора src   
                                                                                
LSL  dest,src  загрузить в dest лимит сегментов из дескриптора src              
                                                                                
ARPL lvl       привести уровень привилегий к наибольшему из текущего и lvl      
                                                                                
VERR seg       уст. ZF=ZR если задача прочитала привилегии для сегмента seg     
                                                                                
VERR seg       уст. ZF=ZR если задача записала привилегии для сегмента seg      

────────────────────────────────────────────────────────────────────────────────
                                                               Набор инструкций 

