#include <iostream>
using namespace std;

// Бинарный алгоритм Евклида
//вычисляет наибольший общий делитель двух натуральных чисел
/*
свойства  НОД 
НОД(2m,2n) = 2 НОД(m ,n),
НОД(2m,2n+1) = НОД(m,2n+1),
НОД(-m,n) = НОД(m,n)

Алгоритм

1.НОД(0, n) = n; НОД(m, 0) = m; 

2. Если m,n чётные, тогда НОД(m, n) = 2*НОД(m/2, n/2)

3. Если m чётная, тогда НОД(m, n) = НОД(m/2, n)
 
4.Если n чётная, тогда НОД(m, n) = НОД(m, n/2). 
5.Если m,n нечётные и m > n, тогда НОД(m, n) = НОД(m - n, n) 

6.Если m,n нечётные и m < n, тогда НОД(m, n) = НОД(n - m, m)

7. Если m = n, тогда НОД(m, n) = m; */

int BinaryNod(int x,int y)
{
     setlocale(LC_ALL,".1251");//Для вывода русского текста
		 int shift;  int nod;
	//НОД(0, x) = x; НОД(y, 0) = y; 
      if (x == 0 || y == 0)
       return x | y;
     
	  /*  shift = наибольшая степень 2 такая, чтобы  x и y разделились на  2    в этой степени . */
	  // числа будут делиться на 2 в степени shift 
      //Пока одно из чисел  не станет четным 
	  for (shift = 0; ((x | y) & 1) == 0; ++shift) 
     { 
         x >>= 1;
         y >>= 1;
      }	

	//Если х чётно, y - нечетно то НОД(x,y) = НОД(x/2, y)
	  
	  /* пока  x не станет нечетным */
	  while ((x & 1) == 0)
       x >>= 1;
     
      /* поке не получим y=0 находим Нод используя  его свойства*/
	  // х должно быть нечетным
      do {
         //если у станет четным, делаем его нечетным
		  while ((y & 1) == 0)  
           y >>= 1;

          /* Если x и y нечетны, то их разность( diff)  -  четна.
             x = min(x, y), y = diff(x,y)/2. */
         if (x < y) {
             y -= x;
         }
	     else {
             unsigned int diff = x - y;
             x = y;
             y = diff;
         }
         y >>= 1;
     } while (y != 0);
 
     nod = x << shift;
	 return nod;
 }

void main()
{
	int r,x,y;
	cin>> x>>y;
	r=BinaryNod(x,y);
	cout<<r;
}

