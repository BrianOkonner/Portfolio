
#include <iostream>
#include <fstream>
using namespace std;
ofstream of("output.txt"); //тут можно посмотреть результаты
static int c=0;

class OX
{   private:
    int num;
  public:
  void print(); 
  void printN(); 
  OX();
  OX(int x);
  // OX(int x=10);
    ~OX () ;
 //   OX(const OX&) ;
  //  OX operator=(const OX);//≈сли без ссылок  еще 6
	//   OX operator=(const &OX);//≈сли без ссылки  еще 2
       //    OX & operator=(const &OX);//≈сли без ссылки  еще 4
       operator int() { return num; }
friend    OX& operator +(  const OX &Y,const OX &Z);//≈сли без ссылoк еще 4
   // OX& operator +(  const OX Y,)//≈сли без ссылoк еще 4
//  OX operator +(  const OX Y)//≈сли без ссылoк еще 4
		
    
	};

   OX& operator +(  const OX &Y,const OX &Z)//≈сли без ссылoк еще 4
   // OX& operator +(  const OX Y,)//≈сли без ссылoк еще 4
//  OX operator +(  const OX Y)//≈сли без ссылoк еще 4
		{of<<"операци€ сложени€"<<endl;
  		OX X;
                X.num=Z.num+Y.num;
	        return X;
		}
    


//  онструктор по умолчанию
OX::OX()
  {
   cout<<"конструктор"<<endl;
   num = 5; print();
  }
//  онструктор 
OX::OX(int x)
  {  
   cout<<"конструктор"<<endl;
   num = x; print();
  }
// ƒеструктор
OX::~OX()
  { 
   cout<<"деструктор"<<endl;
   print();
  }
//  онструктор копий
//OX::OX(const OX& rhs)
//  { 
//   cout<<"конструктор копий"<<endl;
//   num = rhs.num;
//   print();
//  }
// ќпераци€ присваивани€
//OX OX::operator=(const OX rhs)
//  {
//   if(this == &rhs) 
//	  return *this;
//   printN();
//   cout<<"операци€ присваивани€"<<endl;
//   num = rhs. num;
//   print();
//   return *this;
//  }
// ¬озврат по значению
OX Foo(void)
   {    return OX();
   }

void OX::printN()
   { 	cout<<++c<<' ';}
void OX::print()
   { 	cout<<num<<endl;}

void main(void)
 {
   setlocale(LC_ALL,"rus");
   {
   OX Z;   // конструктор
   OX Y=Z; // конструктор копий
   }        // вызов двух деструкторов
  //{
  //  OX A;    // конструктор
  //  OX B(A); // конструктор копий
  //}         // вызов двух деструкторов
  //{
  //  OX C, D; // два конструктора
  //  C=D;    // операци€ присваивани€
  //}         // вызов двух деструкторов
  //{
  //  OX E=Foo() ; // конструктор
  //}             // деструктор
  {
      OX A,C;    // конструктор
      OX B(1000); // конструктор копий
      C=A+B;
	  cout<<"**";
	  C.print();
  }
} 
 /*
		//	≈сть ссылки 
1 конструктор
2 конструктор
3 конструктор копий
4 операци€ сложени€
5 конструктор
6 деструктор
7 операци€ присваивани€
8 деструктор
9 деструктор
10 деструктор */   
		// Ќет ссылок у +
//1 конструктор
//2 конструктор
//3 конструктор копий
//4 конструктор копий
//5 операци€ сложени€
//6 конструктор
//7 конструктор копий
//8 деструктор
//9 деструктор
//10 операци€ присваивани€
//11 деструктор
//12 деструктор
//13 деструктор
//14 деструктор
				// Ќет ссылок у + =
//1 конструктор
//2 конструктор
//3 конструктор копий
//4 конструктор копий
//5 операци€ сложени€
//6 конструктор
//7 конструктор копий
//8 деструктор
//9 деструктор
//10 операци€ присваивани€
//11 конструктор копий
//12 деструктор
//13 деструктор
//14 деструктор
//15 деструктор
//16 деструктор
