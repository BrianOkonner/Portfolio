//Замена в строке слова заданным словом
//Слова разделены символами из заданного множества
//Автор Глиндзич Дмитрий
#include <stdio.h>
#include <stdlib.h>
#include <conio.h>
#include <string.h>

char* repwrd(char*,const char*,const char*,const char*);

void main()
{
 char  c[80], w1[80], w2[80];
 int n;
 printf("Enter your string:");
 gets(c);                                     //Вводим строку
 printf("Enter replaced word:");
 gets(w1);                                    //Вводим заменяемое слово
 printf("Enter new word:");
 gets(w2);                                    //Вводим новое слово
 char *set=" ,;.:_";                          //Множество разделителей
 char*s=repwrd(c,w1,w2,set);                  //Заменяем...
 puts(s);                                     //Выводим результат
 getch();
}

char* repwrd(char *c,const char*w1,const char*w2,const char*set)      //с-исходная строка, w1-заменяемое слово,
{                                                                     //w2-новое слово,  set-разделители
  char* i;                                 //вспомогательный указатель
  int n1=strlen(w1);                       //ищем длины...
  int n2=strlen(w2);
  int m=strlen(c);
  char *S=(char*)malloc(m);                //готовим возвращаемую строку
  strcpy(S,c);                             //копируем в неё исходную
  int ind=0,p=0;                           //р-текущий индекс в просматриваемой строке
  i=strstr(S,w1);                          //ищем первое вхождение слова как подстроки
  if(i)ind=1;                              //если есть:
  while(ind)
    {
      if(i==S||strchr(set,*(i-1)))            //если эта подстрока-слово,
       if(i==S+m-n1||strchr(set,*(i+n1)))     //удаляем его и заменяем новым:
	 {
	  ind=1;                              //т.е.:
	  if(n1>n2)                           //если старое больше нового
	    {
	       int t=n2-1;
	       do                             //Сдвигаем всю строку влево,
		 {                            //укорачивая старое до длины
		   t++;                       //нового
		   i[t]=i[n1-n2+t];
		 }
	       while(i[n1-n2+t]!=NULL);
	    }
	  else if(n1<n2)                          //если старое короче нового
	    {
	      int k=strlen(S);
	      S=(char*)realloc(S,k+n2-n1+1);     //выделяем новую память
	      S[k]=NULL;                         //обозначем в ней конец старой строки
	      i=strstr(S+p,w1);                  //это чтобы вспомогательный указатель продолжал указ.
						 //на нашу непроверенную часть строки
	      while(k>=(i-S)+n1)            	  //Сдвигаем часть строки вправо,
	       {                                  //начиная с конца искомого слова,
		S[k+n2-n1]=S[k];                   //т.е. дополняем до длины нового
		--k;
	       }
	    }
	   for(int t=0;t<n2;++t)                  //записываем на подготовленное место
	     {                                    //нашу строку
	      i[t]=w2[t];
	     }
	 }
       ind=0;
       m=strlen(S);	                          //если дальше в строке встречается старое
       i=strstr(i+n2,w1);                         //слово как подстрока - продолжаем цикл
       if(i&&i<S+m)ind=1;
       p=i-S;                                     //переставляем индекс
    }

  return S;                                       //возвращаем указатель на новую строку
}

